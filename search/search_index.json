{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Electron Survival Guide Motivation You probably read in many places that nodeIntegration set to true is both bad practice and dangerous. You also probably tried turning it off only to see your Electron app hopelessly broken. Don't give up just yet. There is light at the end of the tunnel. I saw it once.","title":"Home"},{"location":"#the-electron-survival-guide","text":"","title":"The Electron Survival Guide"},{"location":"#motivation","text":"You probably read in many places that nodeIntegration set to true is both bad practice and dangerous. You also probably tried turning it off only to see your Electron app hopelessly broken. Don't give up just yet. There is light at the end of the tunnel. I saw it once.","title":"Motivation"},{"location":"howtos/01/","text":"Bad Practice 101 Tldr It is sometimes helpful to know what not to do. Just so we're clear: don't do this! ;) This is only to show how easy it is for any JavaScript code running in the renderer process to behave like a full-blown Node.js program including access to Node.js require and its native APIs. We have also disabled context isolation meaning that any script (including third-party script) can also manipulate the page and its data (e.g. cookies). If your app gets compromised (e.g. XSS, rogue third-party dependency, etc.) the potential for damage is huge. Main Process We have enabled the node integration and disabled context isolation: main.js const { app , BrowserWindow } = require ( 'electron' ); app . whenReady (). then ( async () => { const bwin = new BrowserWindow ({ width : 300 , height : 300 , webPreferences : { nodeIntegration : true , // <- Don't do this! contextIsolation : false // <- Don't do this! } }); await bwin . loadFile ( 'renderer.html' ); bwin . show (); }); Renderer Page We import a script into the page. Third-party scripts will run with the exact same privileges. renderer.html < html > < head > < style > body { background-color : black ; color : limegreen } </ style > </ head > < body > < pre ></ pre > < script src = \"./renderer.js\" ></ script > </ body > </ html > Renderer Script Because node integration is enabled this script has access to the Node.js APIs. We can see that this script is attempting to read a file that was meant to remain secret. Also since the context isolation is disabled this script is sharing the same context execution as the renderer page so can directly modify the DOM and/or read cookies. renderer.js const fs = require ( 'fs' ); const path = require ( 'path' ); const secret = fs . readFileSync ( path . join ( __dirname , 'secret.txt' )); document . querySelector ( 'pre' ). innerHTML = secret ; Screenshot","title":"Bad Practice 101"},{"location":"howtos/01/#bad-practice-101","text":"Tldr It is sometimes helpful to know what not to do. Just so we're clear: don't do this! ;) This is only to show how easy it is for any JavaScript code running in the renderer process to behave like a full-blown Node.js program including access to Node.js require and its native APIs. We have also disabled context isolation meaning that any script (including third-party script) can also manipulate the page and its data (e.g. cookies). If your app gets compromised (e.g. XSS, rogue third-party dependency, etc.) the potential for damage is huge.","title":"Bad Practice 101"},{"location":"howtos/01/#main-process","text":"We have enabled the node integration and disabled context isolation: main.js const { app , BrowserWindow } = require ( 'electron' ); app . whenReady (). then ( async () => { const bwin = new BrowserWindow ({ width : 300 , height : 300 , webPreferences : { nodeIntegration : true , // <- Don't do this! contextIsolation : false // <- Don't do this! } }); await bwin . loadFile ( 'renderer.html' ); bwin . show (); });","title":"Main Process"},{"location":"howtos/01/#renderer-page","text":"We import a script into the page. Third-party scripts will run with the exact same privileges. renderer.html < html > < head > < style > body { background-color : black ; color : limegreen } </ style > </ head > < body > < pre ></ pre > < script src = \"./renderer.js\" ></ script > </ body > </ html >","title":"Renderer Page"},{"location":"howtos/01/#renderer-script","text":"Because node integration is enabled this script has access to the Node.js APIs. We can see that this script is attempting to read a file that was meant to remain secret. Also since the context isolation is disabled this script is sharing the same context execution as the renderer page so can directly modify the DOM and/or read cookies. renderer.js const fs = require ( 'fs' ); const path = require ( 'path' ); const secret = fs . readFileSync ( path . join ( __dirname , 'secret.txt' )); document . querySelector ( 'pre' ). innerHTML = secret ;","title":"Renderer Script"},{"location":"howtos/01/#screenshot","text":"","title":"Screenshot"},{"location":"howtos/02/","text":"Bundling Your Renderer Script Tldr We can use Webpack to package the renderer script (and its dependencies) into a bundle that works in a browser and therefore don't need to turn on nodeIntegration to enable Node.js require . We don't have to disable context isolation either if we simply export a function that we can invoke in the right execution context. Main Process main.js const { app , BrowserWindow } = require ( 'electron' ); app . whenReady (). then ( async () => { const bwin = new BrowserWindow ({ width : 400 , height : 250 , webPreferences : { nodeIntegration : false , // <- Good! contextIsolation : true // <- Nice! } }); await bwin . loadFile ( 'renderer.html' ); bwin . show (); }); Renderer Page Note that we import the bundle not the original source file. renderer.html < html > < head > < style > body { background-color : black ; color : limegreen } </ style > </ head > < body > < pre ></ pre > < script src = \"./renderer.bundle.js\" ></ script > < script > window . app02 ( 'pre' ); </ script > </ body > </ html > Renderer Script This code will eventually run in the renderer process but not as is. This module will get bundled by Webpack into a browser-compatible form. renderer.js const answer = require ( './answer' ); module . exports = sel => { document . querySelector ( sel ). innerHTML = answer (); }; Webpack Configuration The bundle exports a function at window.app02 which can be invoked in the renderer page. webpack.config.js module . exports = { mode : 'production' , context : __dirname , entry : { renderer : './renderer.js' }, output : { path : __dirname , filename : '[name].bundle.js' , library : { type : 'window' , name : 'app02' } } }; Screenshot","title":"Bundling Your Renderer Script"},{"location":"howtos/02/#bundling-your-renderer-script","text":"Tldr We can use Webpack to package the renderer script (and its dependencies) into a bundle that works in a browser and therefore don't need to turn on nodeIntegration to enable Node.js require . We don't have to disable context isolation either if we simply export a function that we can invoke in the right execution context.","title":"Bundling Your Renderer Script"},{"location":"howtos/02/#main-process","text":"main.js const { app , BrowserWindow } = require ( 'electron' ); app . whenReady (). then ( async () => { const bwin = new BrowserWindow ({ width : 400 , height : 250 , webPreferences : { nodeIntegration : false , // <- Good! contextIsolation : true // <- Nice! } }); await bwin . loadFile ( 'renderer.html' ); bwin . show (); });","title":"Main Process"},{"location":"howtos/02/#renderer-page","text":"Note that we import the bundle not the original source file. renderer.html < html > < head > < style > body { background-color : black ; color : limegreen } </ style > </ head > < body > < pre ></ pre > < script src = \"./renderer.bundle.js\" ></ script > < script > window . app02 ( 'pre' ); </ script > </ body > </ html >","title":"Renderer Page"},{"location":"howtos/02/#renderer-script","text":"This code will eventually run in the renderer process but not as is. This module will get bundled by Webpack into a browser-compatible form. renderer.js const answer = require ( './answer' ); module . exports = sel => { document . querySelector ( sel ). innerHTML = answer (); };","title":"Renderer Script"},{"location":"howtos/02/#webpack-configuration","text":"The bundle exports a function at window.app02 which can be invoked in the renderer page. webpack.config.js module . exports = { mode : 'production' , context : __dirname , entry : { renderer : './renderer.js' }, output : { path : __dirname , filename : '[name].bundle.js' , library : { type : 'window' , name : 'app02' } } };","title":"Webpack Configuration"},{"location":"howtos/02/#screenshot","text":"","title":"Screenshot"},{"location":"howtos/03/","text":"Is the app executed from the Applications folder? Tldr It is possible to run an app from its disk image file (e.g. yourapp.dmg ). Sometimes you want to make sure that users have properly installed the app in their Applications folder. See also https://stackoverflow.com/q/65346127/1244884 . Main Process The renderer process can ask if the app is running from the Applications folder by asking in the in-app-folder IPC channel. The main process will respond in that same channel. main.js const { app , BrowserWindow , ipcMain } = require ( 'electron' ); const path = require ( 'path' ); app . whenReady (). then ( async () => { const bwin = new BrowserWindow ({ width : 300 , height : 300 , webPreferences : { nodeIntegration : false , contextIsolation : true , preload : path . resolve ( __dirname , 'preload.js' ) } }); // Must be registered **before** the renderer process starts. ipcMain . handle ( 'in-app-folder' , () => app . isInApplicationsFolder ()); await bwin . loadFile ( 'renderer.html' ); bwin . show (); }); Preload Script The preload script exposes a method under the MY_APP namespace that the renderer process can use to know if the app is run from the Applications folder. preload.js const { contextBridge , ipcRenderer } = require ( 'electron' ); contextBridge . exposeInMainWorld ( 'MY_APP' , { async isInApplicationsFolder () { return ipcRenderer . invoke ( 'in-app-folder' ); } }); Renderer Page The MY_APP namespace is defined in the preload script and contains a method to enquire about the app location. renderer.html < html > < head > < style > body { background-color : black ; color : limegreen } </ style > </ head > < body > < h1 > Are you running this app from the Applications folder? </ h1 > < div id = \"response\" ></ div > < script > MY_APP . isInApplicationsFolder (). then ( yes => { if ( yes ) { document . querySelector ( '#response' ). innerHTML = 'Yes' ; } else { document . querySelector ( '#response' ). innerHTML = 'No' ; } }); </ script > </ body > </ html > Screenshot","title":"Is the app executed from the Applications folder?"},{"location":"howtos/03/#is-the-app-executed-from-the-applications-folder","text":"Tldr It is possible to run an app from its disk image file (e.g. yourapp.dmg ). Sometimes you want to make sure that users have properly installed the app in their Applications folder. See also https://stackoverflow.com/q/65346127/1244884 .","title":"Is the app executed from the Applications folder?"},{"location":"howtos/03/#main-process","text":"The renderer process can ask if the app is running from the Applications folder by asking in the in-app-folder IPC channel. The main process will respond in that same channel. main.js const { app , BrowserWindow , ipcMain } = require ( 'electron' ); const path = require ( 'path' ); app . whenReady (). then ( async () => { const bwin = new BrowserWindow ({ width : 300 , height : 300 , webPreferences : { nodeIntegration : false , contextIsolation : true , preload : path . resolve ( __dirname , 'preload.js' ) } }); // Must be registered **before** the renderer process starts. ipcMain . handle ( 'in-app-folder' , () => app . isInApplicationsFolder ()); await bwin . loadFile ( 'renderer.html' ); bwin . show (); });","title":"Main Process"},{"location":"howtos/03/#preload-script","text":"The preload script exposes a method under the MY_APP namespace that the renderer process can use to know if the app is run from the Applications folder. preload.js const { contextBridge , ipcRenderer } = require ( 'electron' ); contextBridge . exposeInMainWorld ( 'MY_APP' , { async isInApplicationsFolder () { return ipcRenderer . invoke ( 'in-app-folder' ); } });","title":"Preload Script"},{"location":"howtos/03/#renderer-page","text":"The MY_APP namespace is defined in the preload script and contains a method to enquire about the app location. renderer.html < html > < head > < style > body { background-color : black ; color : limegreen } </ style > </ head > < body > < h1 > Are you running this app from the Applications folder? </ h1 > < div id = \"response\" ></ div > < script > MY_APP . isInApplicationsFolder (). then ( yes => { if ( yes ) { document . querySelector ( '#response' ). innerHTML = 'Yes' ; } else { document . querySelector ( '#response' ). innerHTML = 'No' ; } }); </ script > </ body > </ html >","title":"Renderer Page"},{"location":"howtos/03/#screenshot","text":"","title":"Screenshot"},{"location":"howtos/04/","text":"Observable IPC Channels Tldr Transform main-to-renderer communication channels into observables that you can process and subscribe to. Main Process The main process sends some data to the renderer process on the count channel every 500ms. main.js const { app , BrowserWindow } = require ( 'electron' ); const path = require ( 'path' ); app . whenReady (). then ( async () => { const bwin = new BrowserWindow ({ width : 600 , height : 600 , webPreferences : { nodeIntegration : false , contextIsolation : true , preload : path . resolve ( __dirname , 'preload.js' ) } }); await bwin . loadFile ( 'renderer.html' ); bwin . show (); bwin . webContents . openDevTools (); let count = 0 ; setInterval (() => { bwin . webContents . send ( 'count' , count ++ ); // Send to renderer process. }, 500 ); }); Preload Script The on method returns a pair of functions to be used with RxJS's fromEventPattern function. preload.js const { contextBridge , ipcRenderer } = require ( 'electron' ); contextBridge . exposeInMainWorld ( 'MY_APP' , { on : channel => ([ ( handler ) => { // addListener function _handler ( ev , ... args ) { console . log ( `Received from channel ' ${ channel } ':` , ... args ); handler (... args ); } console . log ( `Start observing from ipcRenderer.on(' ${ channel } ')` ); ipcRenderer . on ( channel , _handler ); return _handler ; }, // | // +--+ // | // v ( _ , _handler ) => { // removeListener console . log ( `Stop observing from ipcRenderer.on(' ${ channel } ')` ); ipcRenderer . removeListener ( channel , _handler ); } ]) }); Renderer Page We use the pair of functions returned by MY_APP.on('count') with RxJS's fromEventPattern function to get an observable on that channel. Every time the main process emits on that channel that observable will emit the same thing. renderer.html < html > < head > < style > body { background-color : black ; color : limegreen } </ style > < script src = \"https://unpkg.com/rxjs@7.5.5/dist/bundles/rxjs.umd.min.js\" ></ script > </ head > < body > < div id = \"response\" ></ div > < script > const { fromEventPattern } = rxjs ; const { take } = rxjs . operators ; const [ addListener , removeListener ] = window . MY_APP . on ( 'count' ); const count$ = fromEventPattern ( addListener , removeListener ). pipe ( take ( 5 ) // Unsubscribe automatically after 5 emissions. ); count$ . subscribe (( count ) => { document . querySelector ( '#response' ). innerHTML += ` ${ count } <br>` ; }); </ script > </ body > </ html > Screenshot","title":"Observable IPC Channels"},{"location":"howtos/04/#observable-ipc-channels","text":"Tldr Transform main-to-renderer communication channels into observables that you can process and subscribe to.","title":"Observable IPC Channels"},{"location":"howtos/04/#main-process","text":"The main process sends some data to the renderer process on the count channel every 500ms. main.js const { app , BrowserWindow } = require ( 'electron' ); const path = require ( 'path' ); app . whenReady (). then ( async () => { const bwin = new BrowserWindow ({ width : 600 , height : 600 , webPreferences : { nodeIntegration : false , contextIsolation : true , preload : path . resolve ( __dirname , 'preload.js' ) } }); await bwin . loadFile ( 'renderer.html' ); bwin . show (); bwin . webContents . openDevTools (); let count = 0 ; setInterval (() => { bwin . webContents . send ( 'count' , count ++ ); // Send to renderer process. }, 500 ); });","title":"Main Process"},{"location":"howtos/04/#preload-script","text":"The on method returns a pair of functions to be used with RxJS's fromEventPattern function. preload.js const { contextBridge , ipcRenderer } = require ( 'electron' ); contextBridge . exposeInMainWorld ( 'MY_APP' , { on : channel => ([ ( handler ) => { // addListener function _handler ( ev , ... args ) { console . log ( `Received from channel ' ${ channel } ':` , ... args ); handler (... args ); } console . log ( `Start observing from ipcRenderer.on(' ${ channel } ')` ); ipcRenderer . on ( channel , _handler ); return _handler ; }, // | // +--+ // | // v ( _ , _handler ) => { // removeListener console . log ( `Stop observing from ipcRenderer.on(' ${ channel } ')` ); ipcRenderer . removeListener ( channel , _handler ); } ]) });","title":"Preload Script"},{"location":"howtos/04/#renderer-page","text":"We use the pair of functions returned by MY_APP.on('count') with RxJS's fromEventPattern function to get an observable on that channel. Every time the main process emits on that channel that observable will emit the same thing. renderer.html < html > < head > < style > body { background-color : black ; color : limegreen } </ style > < script src = \"https://unpkg.com/rxjs@7.5.5/dist/bundles/rxjs.umd.min.js\" ></ script > </ head > < body > < div id = \"response\" ></ div > < script > const { fromEventPattern } = rxjs ; const { take } = rxjs . operators ; const [ addListener , removeListener ] = window . MY_APP . on ( 'count' ); const count$ = fromEventPattern ( addListener , removeListener ). pipe ( take ( 5 ) // Unsubscribe automatically after 5 emissions. ); count$ . subscribe (( count ) => { document . querySelector ( '#response' ). innerHTML += ` ${ count } <br>` ; }); </ script > </ body > </ html >","title":"Renderer Page"},{"location":"howtos/04/#screenshot","text":"","title":"Screenshot"},{"location":"howtos/05/","text":"Can I share an IPC channel with multiple processes? Tldr Multiple renderer processes can invoke the main process on the same channel. The main process always respond to the correct renderer process. Main Process The main process starts four renderer processes. Each one of them will invoke the main process on the echo channel. main.js const { app , BrowserWindow , ipcMain } = require ( 'electron' ); const path = require ( 'path' ); app . whenReady (). then ( async () => { const winDef = { width : 200 , height : 400 , webPreferences : { nodeIntegration : false , contextIsolation : true , preload : path . resolve ( __dirname , 'preload.js' ) } }; const bwin1 = new BrowserWindow ({ title : 'FOO' , x : 20 , y : 60 , ... winDef }); const bwin2 = new BrowserWindow ({ title : 'BAR' , x : 230 , y : 60 , ... winDef }); const bwin3 = new BrowserWindow ({ title : 'BAZ' , x : 440 , y : 60 , ... winDef }); const bwin4 = new BrowserWindow ({ title : 'BAT' , x : 650 , y : 60 , ... winDef }); await bwin1 . loadFile ( 'renderer.html' ); bwin1 . show (); await bwin2 . loadFile ( 'renderer.html' ); bwin2 . show (); await bwin3 . loadFile ( 'renderer.html' ); bwin3 . show (); await bwin4 . loadFile ( 'renderer.html' ); bwin4 . show (); ipcMain . handle ( 'echo' , ( _ , any ) => any ); }); Preload Script The MY_APP.echo method will invoke the main process on the echo channel with some value. The main process simply answer back with the same value. preload.js const { contextBridge , ipcRenderer } = require ( 'electron' ); contextBridge . exposeInMainWorld ( 'MY_APP' , { echo ( any ) { return ipcRenderer . invoke ( 'echo' , any ); } }); Renderer Page Each renderer process creates a unique random value at the start and keep sending it back to the main process which responds by echoing back that same value. renderer.html < html > < head > < style > body { background-color : black ; color : limegreen } </ style > </ head > < body > < div id = \"response\" ></ div > < script > const rand = Math . random (); setInterval (() => { MY_APP . echo ( rand ). then ( any => { document . querySelector ( '#response' ). innerHTML += ` ${ any } <br>` ; }); }, 1000 ); </ script > </ body > </ html > Screenshot","title":"Can I share an IPC channel with multiple processes?"},{"location":"howtos/05/#can-i-share-an-ipc-channel-with-multiple-processes","text":"Tldr Multiple renderer processes can invoke the main process on the same channel. The main process always respond to the correct renderer process.","title":"Can I share an IPC channel with multiple processes?"},{"location":"howtos/05/#main-process","text":"The main process starts four renderer processes. Each one of them will invoke the main process on the echo channel. main.js const { app , BrowserWindow , ipcMain } = require ( 'electron' ); const path = require ( 'path' ); app . whenReady (). then ( async () => { const winDef = { width : 200 , height : 400 , webPreferences : { nodeIntegration : false , contextIsolation : true , preload : path . resolve ( __dirname , 'preload.js' ) } }; const bwin1 = new BrowserWindow ({ title : 'FOO' , x : 20 , y : 60 , ... winDef }); const bwin2 = new BrowserWindow ({ title : 'BAR' , x : 230 , y : 60 , ... winDef }); const bwin3 = new BrowserWindow ({ title : 'BAZ' , x : 440 , y : 60 , ... winDef }); const bwin4 = new BrowserWindow ({ title : 'BAT' , x : 650 , y : 60 , ... winDef }); await bwin1 . loadFile ( 'renderer.html' ); bwin1 . show (); await bwin2 . loadFile ( 'renderer.html' ); bwin2 . show (); await bwin3 . loadFile ( 'renderer.html' ); bwin3 . show (); await bwin4 . loadFile ( 'renderer.html' ); bwin4 . show (); ipcMain . handle ( 'echo' , ( _ , any ) => any ); });","title":"Main Process"},{"location":"howtos/05/#preload-script","text":"The MY_APP.echo method will invoke the main process on the echo channel with some value. The main process simply answer back with the same value. preload.js const { contextBridge , ipcRenderer } = require ( 'electron' ); contextBridge . exposeInMainWorld ( 'MY_APP' , { echo ( any ) { return ipcRenderer . invoke ( 'echo' , any ); } });","title":"Preload Script"},{"location":"howtos/05/#renderer-page","text":"Each renderer process creates a unique random value at the start and keep sending it back to the main process which responds by echoing back that same value. renderer.html < html > < head > < style > body { background-color : black ; color : limegreen } </ style > </ head > < body > < div id = \"response\" ></ div > < script > const rand = Math . random (); setInterval (() => { MY_APP . echo ( rand ). then ( any => { document . querySelector ( '#response' ). innerHTML += ` ${ any } <br>` ; }); }, 1000 ); </ script > </ body > </ html >","title":"Renderer Page"},{"location":"howtos/05/#screenshot","text":"","title":"Screenshot"}]}